const mongoose = require('mongoose');

const reportSchema = new mongoose.Schema({
  facultyId: { 
    type: mongoose.Schema.Types.ObjectId, 
    ref: 'User', 
    required: true 
  },
  year: { 
    type: Number, 
    required: true 
  },
  semester: { 
    type: String,
    enum: ['1', '2', 'annual'],
    default: 'annual'
  },
  reportType: { 
    type: String, 
    enum: ['monthly', 'quarterly', 'annual'], 
    required: true 
  },
  month: {
    type: Number,
    min: 1,
    max: 12
  },
  quarter: {
    type: Number,
    min: 1,
    max: 4
  },
  data: {
    seminars: { 
      type: Number, 
      default: 0 
    },
    journals: { 
      type: Number, 
      default: 0 
    },
    books: { 
      type: Number, 
      default: 0 
    },
    phd: { 
      type: Number, 
      default: 0 
    },
    awards: { 
      type: Number, 
      default: 0 
    },
    patents: { 
      type: Number, 
      default: 0 
    },
    visits: { 
      type: Number, 
      default: 0 
    },
    grants: { 
      type: Number, 
      default: 0 
    },
    consultancy: { 
      type: Number, 
      default: 0 
    },
    infrastructure: {
      type: Number,
      default: 0
    }
  },
  financialData: {
    totalGrants: { type: Number, default: 0 },
    totalConsultancy: { type: Number, default: 0 },
    totalAwards: { type: Number, default: 0 },
    totalInfrastructure: { type: Number, default: 0 }
  },
  highlights: [{
    type: String,
    trim: true
  }],
  achievements: [{
    title: String,
    description: String,
    impact: String
  }],
  challenges: [{
    description: String,
    impact: String,
    solutions: String
  }],
  goals: [{
    description: String,
    timeline: String,
    status: {
      type: String,
      enum: ['pending', 'in-progress', 'completed'],
      default: 'pending'
    }
  }],
  generatedBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User'
  },
  isAutoGenerated: {
    type: Boolean,
    default: false
  },
  status: {
    type: String,
    enum: ['draft', 'submitted', 'approved', 'rejected'],
    default: 'draft'
  },
  submittedAt: Date,
  approvedBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User'
  },
  approvedAt: Date,
  comments: [{
    user: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User'
    },
    comment: String,
    timestamp: {
      type: Date,
      default: Date.now
    }
  }]
}, {
  timestamps: true,
  toJSON: { virtuals: true },
  toObject: { virtuals: true }
});

// Virtual for faculty details
reportSchema.virtual('faculty', {
  ref: 'User',
  localField: 'facultyId',
  foreignField: '_id',
  justOne: true
});

// Virtual for total research count
reportSchema.virtual('totalResearch').get(function() {
  return Object.values(this.data).reduce((sum, count) => sum + count, 0);
});

// Virtual for total financial value
reportSchema.virtual('totalFinancialValue').get(function() {
  return Object.values(this.financialData).reduce((sum, amount) => sum + amount, 0);
});

// Indexes for better query performance
// reportSchema.index({ facultyId: 1 });
// reportSchema.index({ year: 1 });
// reportSchema.index({ reportType: 1 });
// reportSchema.index({ status: 1 });
// reportSchema.index({ facultyId: 1, year: 1 });
// reportSchema.index({ facultyId: 1, year: 1, semester: 1 });

// Static method to find by faculty and year
reportSchema.statics.findByFacultyAndYear = function(facultyId, year) {
  return this.find({ facultyId, year }).populate('faculty', 'name email department');
};

// Static method to find pending reports
reportSchema.statics.findPending = function() {
  return this.find({ status: 'submitted' }).populate('faculty', 'name email department');
};

// Static method to generate report automatically
reportSchema.statics.generateReport = async function(facultyId, year, semester = 'annual') {
  const Research = require('./Research');
  
  // Build date filter based on semester
  let dateFilter = {
    facultyId,
    date: {
      $gte: new Date(year, 0, 1),
      $lt: new Date(year + 1, 0, 1)
    }
  };
  
  if (semester === '1') {
    dateFilter.date = {
      $gte: new Date(year, 0, 1),
      $lt: new Date(year, 6, 1)
    };
  } else if (semester === '2') {
    dateFilter.date = {
      $gte: new Date(year, 6, 1),
      $lt: new Date(year + 1, 0, 1)
    };
  }
  
  // Get research statistics
  const stats = await Research.getStats(dateFilter);
  
  // Calculate financial data
  const financialData = await Research.aggregate([
    { $match: dateFilter },
    {
      $group: {
        _id: null,
        totalGrants: { $sum: '$details.grantAmount' },
        totalConsultancy: { $sum: '$details.projectValue' },
        totalAwards: { $sum: '$details.amount' },
        totalInfrastructure: { $sum: '$details.equipmentValue' }
      }
    }
  ]);
  
  // Create report data
  const reportData = {
    seminars: 0,
    journals: 0,
    books: 0,
    phd: 0,
    awards: 0,
    patents: 0,
    visits: 0,
    grants: 0,
    consultancy: 0,
    infrastructure: 0
  };
  
  // Map statistics to report data
  stats.forEach(stat => {
    if (reportData.hasOwnProperty(stat._id)) {
      reportData[stat._id] = stat.count;
    }
  });
  
  const financial = financialData[0] || {
    totalGrants: 0,
    totalConsultancy: 0,
    totalAwards: 0,
    totalInfrastructure: 0
  };
  
  return {
    facultyId,
    year,
    semester,
    reportType: 'annual',
    data: reportData,
    financialData: financial,
    isAutoGenerated: true,
    status: 'draft'
  };
};

module.exports = mongoose.model('Report', reportSchema); 